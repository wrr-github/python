# 第一部分 概论

## 第1章 导论

## 第2章 操作系统结构

### 一、操作系统提供的服务和功能

#### 1、用户服务

1. 用户界面(User Interface，UI)

   - 命令行界面(Command-Line Interface，CLI)：命令解释程序称为外壳(shell)。

   - 批处理界面(batch interface)

   - 图形用户界面(Graphical User Interface，GUI)

2. 程序执行

   - 系统加载程序到内存并运行程序

   - 程序应能结束运行，包括正常或不正常

3. I/O操作

4. 文件系统操作

5. 通信

   - 共享内存：shared memory，两个或多个进程读写共享内存区域。

   - 消息交换：message passing，符合预先定义格式的信息分组可以通过操作系统在进程之间移动。

6. 错误检测

#### 2、操作系统服务

1. 资源分配：多个用户或多个作业同时运行时的资源分配

 2. 记账：统计用户使用资源的类型和数量
 3. 保护与安全

### 二、系统调用

system call，提供操作系统服务接口。应用程序开发人员可以根据应用编程接口(Application Programming Interface，API)来设计程序。

#### 1、向操作系统传递参数

1. 直接通过寄存器传递
2. 参数存在内存的块或表中，块或表的地址通过寄存器来传递
3. 通过程序放在或压入(push)到堆栈(stack)，并通过操作系统弹出(pop)

#### 2、系统调用类型

1. 进程控制(process control)
   - 结束、中止
   - 加载、执行
   - 创建进程、终止进程
   - 获取、设置进程属性
   - 等待时间
   - 等待事件、信号事件
   - 分配和释放内存

2. 文件管理(file manipulation)

   - 创建create()

   - 删除delete()

   - 打开open()

   - 读read()

   - 写write()

   - 重定位reposition()

   - 关闭close()

3. 设备管理(device manipulation)

   - 请求request()

   - 释放release()

   请求设备后的操作类似于文件，实现一组系统调用同时用于文件和设备。

   缺点：多设备间系统调用容易发生死锁

4. 信息维护(information maintenance)

   用于在用户程序和操作系统之间传递信息。

   - 当前时间time()
   - 当前日期date()
   - 转储内存dump()

5. 通信(communication)

   - 消息传递模型(message-passing model)：可用于少量数据交换，更容易实现

   - 共享内存模型(shared-memory model)

     - 优点：高速便捷

     - 缺点：保护和同步方面有问题

6. 保护(protection)

### 四、策略与机制

机制决定如何做，策略决定做什么，机制与策略的分离可增加灵活性

### 五、操作系统的结构

#### 1、简单结构

缺乏明确定义的结构。

#### 2、分层方法

操作系统分成若干层，最低层为硬件，最高层为用户接口，要求每层只能调用更底层的功能和服务。

- 优点：简化了构造和调试
- 难点：如何合理定义分层
- 缺点：效率较低，每层都为系统调用增加额外开销

#### 3、微内核

从内核中删除所有不必要的部件，而将他们当作系统级与用户级的程序来实现。

- 功能：为客户端程序和运行在用户空间中的各种服务提供通信，通信是通过消息传递来提供的。

- 优点：便于扩展操作
- 系统，提供了更好的安全性和可靠性
- 缺点：系统功能开销大，微内核性能受损

#### 4、模块

可加载内核模块：内核提供核心服务，而其他服务可在内核运行时以模块形式调用。

- 优点：效率更高，无需通过消息传递进行通信

#### 5、混合系统

组合不同结构，以便解决性能、安全性和可用性等问题。

# 第二部分 进程管理

## 第3章 进程

### 一、概念

当一个可执行文件被加载到内存时，这个程序就成为进程，进程是执行的程序。

#### 1、进程状态

- 新的new：进程正在创建

- 运行running：指令正在执行

- 等待waiting：进程等待发生某个事件（如I/O完成或收到信号）

- 就绪ready：进程等待分配处理器

- 终止terminated：进程已经完成执行

  一次只有一个进程可在一个处理器上运行(running)，但是许多进程可处于就绪(ready)或等待(waiting)状态。

#### 2、进程控制块

Process Control Block，PCB，包含：

- 进程状态(process status)
- 程序计数器(program counter)：计数器表示进程将要执行的下个指令的地址。
- CPU寄存器(CPU register)：包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器。
- CPU调度信息(CPU-scheduling information)：包括进程优先级、调度队列的指针和其他调度参数。
- 内存管理信息(memory-management information)：包括基地址和界限寄存器的值、页表或段表。
- 记账信息(accounting information)：包括CPU时间、实际使用时间、时间期限、记账数据、作业或进程数量等。
- I/O状态信息(I/O status information)：包括分配给进程的I/O设备列表、打开文件列表等。

### 二、进程调度

进程调度器(process scheduler)选择一个可用进程到CPU上执行。

#### 1、调度队列

- 作业队列(job queue)：进程进入系统时，会被加到作业队列。这个队列包括系统内的所有进程。
- 就绪队列(ready queue)：驻留在内存中的、就绪的、等待运行的进程保存在就绪队列。
- 设备队列(device queue)：等待特定I/O设备的进程列表。

![img](https://img1.baidu.com/it/u=1371470847,3274411292&fm=26&fmt=auto&gp=0.jpg)

#### 2、调度程序

- 长期调度程序(long-term scheduler)/作业调度程序(job scheduler)：对于批处理系统，提交的进程多于可以立即执行的，这些进程会被保存到大容量存储设备（通常为磁盘）的缓冲池，以便以后执行。该程序从缓冲池中选择进程，加到内存，以便执行。可控制多道程序程度(degree of multiprogramming)（内存中的进程数量），并保证I/O密集型和CPU密集型的合理进程组合。新进程创建频率较低，可承担更多时间。
  - I/O密集型进程(I/O-bound process)：执行I/O比执行计算需要花费更多时间。
  - CPU密集型进程(CPU-bound process)：很少产生I/O请求，更多时间用于执行计算。
- 中期调度程序(medium-term scheduler)：可将进程从内存（或从CPU竞争）中移出（换出），从而降低多道程序程度，之后进程可被重新调入内存（换入），并从中断处继续执行，该方案称为交换。作用：改善进程组合；内存需求改变导致过度使用内存从而需要释放内存。
- 短期调度程序(short-term scheduler)/CPU调度程序(CPU scheduler)：从内存中准备执行的进程中选择进程，并分配CPU。进程执行时间较短，频率较高，因此短期调度程序必须快速。

#### 3、上下文切换

context switch，切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态的过程。当进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。

### 三、进程运行

#### 1、进程创建

进程可创建新的进程，创建进程称为父进程，新进程称为子进程。父进程可能要在子进程之间分配资源或共享资源(如内存或文件)，传递初始化数据。限制子进程只能使用父进程的资源，可以防止创建过多进程，导致系统超载。

执行可能：

- 父进程与子进程并发执行。
- 父进程等待，知道某个或全部子进程执行完。

进程创建后拥有唯一进程标识符pid，可以用作索引访问内核中的进程的各种属性。对于新(子)进程，系统调用fork()的返回值为0；对于父进程，返回值为子进程的进程标识符(非零)。在系统调用fork()之后，有个进程使用系统调用exec()，以用新进程来取代进程的内存空间。

#### 2、进程终止

进程执行完后通过系统调用exit()请求操作系统删除自身时进程终止，这时会返回状态值到父进程（通过系统调用wait()）。

- 僵尸进程：子进程已经终止，但父进程未调用wait()
- 孤儿进程：父进程未调用wait()即终止，子进程称为孤儿进程。linux根进程init通过定期调用wait()释放孤儿进程。

### 四、进程间通信

InterProcess Communication，IPC。

#### 1、共享内存

shared memory，生产者(producer)进程生成消息，以供消费者(consumer)进程消费。共享内存提供缓冲区。

- 无界缓冲区(unbounded-buffer)：不限制缓冲区的大小。消费者可能不得不等待新的项，但生产者总是可以产生新项。
- 有界缓冲区(bounded-buffer)：假设固定大小的缓冲区。如果缓冲区空，那么消费者必须等待；如果缓冲区满，那么生产者必须等待。

#### 2、消息传递

message passing

通信链路(communication link)：

- 直接通信(direct communication)：需要通信的每个进程必须明确指定通信的接收者或发送者。缺点：硬编码(hard-coding)，必须指定进程标识符，更改标识符需更改所有引用。

  - 对称性(symmetry)寻址：

    - send(P, message)：向进程P发送message。
    - receive(Q, message)：从进程Q接收message。

    属性：

    - 在需要通信的每对进程之间，自动建立链路。进程仅需知道对方身份就可进行交流。
    - 每个链路只与两个进程相关。
    - 每对进程之间只有一个链路。

  - 非对称性(asymmetry)寻址：

    - send(P, message)：向进程P发送message。
    - receive(id, message)：从任何进程，接收message，变量id为与其他进程通信的名称。

- 间接通信(indirect communication)：通过邮箱或端口来发送或接收消息，每个邮箱都采用唯一的标识符。

  - send(A, message)：向邮箱A发送message。
  - receive(A, message)：从邮箱A接收message。

  特点：

  - 只有在两个进程共享一个邮箱时，才能建立通信链路。
  - 一个链路可以与两个或更多进程相关联。
  - 两个通信进程之间可有多个不同链路，每个链路对应于一个邮箱。

#### 3、同步

消息传递方式：

- 阻塞发送(blocking send)：发送进程阻塞，直到消息由接收进程或邮箱所接收。
- 非阻塞发送(nonblocking send)：发送进程发送消息，并且恢复操作。
- 阻塞接收(blocking receive)：接收进程阻塞，直到有消息可用。
- 非阻塞接收(nonblocking receive)：接收进程收到一个有效消息或空消息。

#### 4、缓存

通信进程交换的消息总是驻留在临时队列中，队列实现的方法：

- 零容量(zero capacity)：队列的最大长度为0，发送者应阻塞，直到接收者接收消息。
- 有限容量(bounded capacity)：队列长度为有限的n，如果链路已满，发送者应阻塞，直到队列空间有可用的为止。
- 无限容量(unbounded capacity)：队列长度可以无限，发送者从不阻塞。

### 五、客户机/服务器通信

#### 1、套接字

socket，为通信的端点，通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个，每个套接字由一个IP地址和一个端口号组成。通常，套接字采用客户机-服务器架构，只允许在通信线程之间交换无结构的字节流。

回送loopback：特殊IP地址127.0.0.1，指引用自己。

#### 2、远程过程调用

RPC，交换的消息具有明确结构，允许客户调用位于远程主机的过程。

#### 3、管道

pipe，允许两个进程进行通信。

- 普通管道：允许两个进程按标准的生产者-消费者方式进行通信，生产者向管道的一端(写入端)写，消费者从管道的另一端(读出端)读。只允许单向通信，只可用于同一机器的进程间通信。
- 命名管道：通信可以是双向的，UNIX系统只允许半双工(数据在同一时间内只能按一个方向传输)通信，Windows系统允许全双工(数据在同一时间内可在两个方向传输)通信。若在不同系统间通信，需要使用套接字。

## 第4章 多线程编程

### 1、概述

每个线程是CPU使用的一个基本单元，包括线程ID、程序计数器、寄存器组和堆栈。同一进程中的线程共享代码段、数据段和其他操作系统资源。

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages2017.cnblogs.com%2Fblog%2F722623%2F201710%2F722623-20171004213747896-440620687.png&refer=http%3A%2F%2Fimages2017.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621428634&t=34d358df253d37ecada5f16dbcaf6f58)

优点：

- 响应性：如果一个交互程序采用多线程，那么即使部分阻塞或者执行冗长操作，它仍可以继续执行，从而增加对用户的响应程度。
- 资源共享：线程默认共享它们所属进程的内存和资源。代码和数据共享的优点是，它允许一个应用程序在同一地址空间内有多个不同活动线程。
- 经济：由于线程能够共享它们所属进程的资源，所以创建和切换线程更加经济。
- 可伸缩性：线程可在多处理核上并行运行。单线程进程只能运行在一个CPU上。

### 2、多核编程

- 并发性(concurrency)：单核系统上多个线程为并发执行。
- 并行性(parallelism)：多核系统上多个线程为并行执行。
  - 数据并行(data parallelism)：注重将数据分布于多个计算核上，并在每个核上执行相同操作。
  - 任务并行(task parallelism)：涉及将任务（线程）而不是数据分配到多个计算核，每个线程都执行一个独特的操作。

### 3、多线程模型

- 多对一模型：映射多个用户级线程到一个内核线程，内核一次只能调用一个线程。

  - 优点：线程管理是由用户空间的线程库来完成的，因此效率更高。
  - 缺点：线程无法并发运行，任一时间只有一个线程可以访问内核，所以多个线程不能并行运行在多处理核系统上。

- 一对一模型：映射每个用户线程到一个内核线程。

  - 优点：线程能够并发运行，同时允许多个线程并行运行在多处理器系统上。
  - 缺点：创建一个用户线程就要创建一个相应的内核线程。

- 多对多模型：多路复用多个用户级线程到同样数量或更少数量的内核线程。

- 双层模型(tow-level model)：允许多路复用多个用户级线程到同样数量或更少数量的内核线程，也允许绑定某个用户线程到一个内核线程。

  ![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.cxybcw.com%2Fwp-content%2Fuploads%2F2020%2F02%2Fbeepress1-1580908628.gif&refer=http%3A%2F%2Fwww.cxybcw.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621430116&t=1006d156118301ca79eb9ca250edadd4)

### 4、线程库

thread library，为程序员提供创建和管理线程的API。

- POSIX Pthreads：可以提供用户级或内核级的库，是POSIX标准定义的线程创建与同步的API。
- Windows线程库：用于Windows操作系统的内核级线程库。
- Java线程API：允许线程在Java程序中直接创建和管理。

多线程创建的策略：

- 异步线程：一旦父线程创建了一个子线程后，父线程就恢复自身的执行，这样父线程与子线程会并发执行。
- 同步线程：由父线程创建的线程并发执行工作，但是父线程在这个工作完成之前无法继续。

### 5、隐式多线程

1. 线程池(thread pool)：在进程开始时创建一定数量的线程，并加到池中以等待工作。

   优点：

   - 用现有线程服务请求比等待创建一个线程更快。
   - 线程池限制了任何时候可用线程的数量。
   - 将要执行任务从创建任务的机制中分离出来，允许我们采用不同策略运行任务。