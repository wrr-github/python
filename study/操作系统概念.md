# 第一部分 概论

## 第1章 导论

## 第2章 操作系统结构

### 一、操作系统提供的服务和功能

#### 1、用户服务

1. 用户界面(User Interface，UI)

   - 命令行界面(Command-Line Interface，CLI)：命令解释程序称为外壳(shell)。

   - 批处理界面(batch interface)

   - 图形用户界面(Graphical User Interface，GUI)

2. 程序执行

   - 系统加载程序到内存并运行程序

   - 程序应能结束运行，包括正常或不正常

3. I/O操作

4. 文件系统操作

5. 通信

   - 共享内存：shared memory，两个或多个进程读写共享内存区域。

   - 消息交换：message passing，符合预先定义格式的信息分组可以通过操作系统在进程之间移动。

6. 错误检测

#### 2、操作系统服务

1. 资源分配：多个用户或多个作业同时运行时的资源分配

 2. 记账：统计用户使用资源的类型和数量
 3. 保护与安全

### 二、系统调用

system call，提供操作系统服务接口。应用程序开发人员可以根据应用编程接口(Application Programming Interface，API)来设计程序。

#### 1、向操作系统传递参数

1. 直接通过寄存器传递
2. 参数存在内存的块或表中，块或表的地址通过寄存器来传递
3. 通过程序放在或压入(push)到堆栈(stack)，并通过操作系统弹出(pop)

#### 2、系统调用类型

1. 进程控制(process control)
   - 结束、中止
   - 加载、执行
   - 创建进程、终止进程
   - 获取、设置进程属性
   - 等待时间
   - 等待事件、信号事件
   - 分配和释放内存

2. 文件管理(file manipulation)

   - 创建create()

   - 删除delete()

   - 打开open()

   - 读read()

   - 写write()

   - 重定位reposition()

   - 关闭close()

3. 设备管理(device manipulation)

   - 请求request()

   - 释放release()

   请求设备后的操作类似于文件，实现一组系统调用同时用于文件和设备。

   缺点：多设备间系统调用容易发生死锁

4. 信息维护(information maintenance)

   用于在用户程序和操作系统之间传递信息。

   - 当前时间time()
   - 当前日期date()
   - 转储内存dump()

5. 通信(communication)

   - 消息传递模型(message-passing model)：可用于少量数据交换，更容易实现

   - 共享内存模型(shared-memory model)

     - 优点：高速便捷

     - 缺点：保护和同步方面有问题

6. 保护(protection)

### 四、策略与机制

机制决定如何做，策略决定做什么，机制与策略的分离可增加灵活性

### 五、操作系统的结构

#### 1、简单结构

缺乏明确定义的结构。

#### 2、分层方法

操作系统分成若干层，最低层为硬件，最高层为用户接口，要求每层只能调用更底层的功能和服务。

- 优点：简化了构造和调试
- 难点：如何合理定义分层
- 缺点：效率较低，每层都为系统调用增加额外开销

#### 3、微内核

从内核中删除所有不必要的部件，而将他们当作系统级与用户级的程序来实现。

- 功能：为客户端程序和运行在用户空间中的各种服务提供通信，通信是通过消息传递来提供的。

- 优点：便于扩展操作
- 系统，提供了更好的安全性和可靠性
- 缺点：系统功能开销大，微内核性能受损

#### 4、模块

可加载内核模块：内核提供核心服务，而其他服务可在内核运行时以模块形式调用。

- 优点：效率更高，无需通过消息传递进行通信

#### 5、混合系统

组合不同结构，以便解决性能、安全性和可用性等问题。

# 第二部分 进程管理

## 第3章 进程

### 一、概念

当一个可执行文件被加载到内存时，这个程序就成为进程。

#### 1、进程状态

- 新的new：进程正在创建

- 运行running：指令正在执行

- 等待waiting：进程等待发生某个事件（如I/O完成或收到信号）

- 就绪ready：进程等待分配处理器

- 终止terminated：进程已经完成执行

  一次只有一个进程可在一个处理器上运行(running)，但是许多进程可处于就绪(ready)或等待(waiting)状态。

#### 2、进程控制块

Process Control Block，PCB，包含：

- 进程状态(process status)
- 程序计数器(program counter)：计数器表示进程将要执行的下个指令的地址。
- CPU寄存器(CPU register)：包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器。
- CPU调度信息(CPU-scheduling information)：包括进程优先级、调度队列的指针和其他调度参数。
- 内存管理信息(memory-management information)：包括基地址和界限寄存器的值、页表或段表。
- 记账信息(accounting information)：包括CPU时间、实际使用时间、时间期限、记账数据、作业或进程数量等。
- I/O状态信息(I/O status information)：包括分配给进程的I/O设备列表、打开文件列表等。

### 二、进程调度

进程调度器(process scheduler)选择一个可用进程到CPU上执行。

#### 1、调度队列

- 作业队列(job queue)：进程进入系统时，会被加到作业队列。这个队列包括系统内的所有进程。
- 就绪队列(ready queue)：驻留在内存中的、就绪的、等待运行的进程保存在就绪队列。
- 设备队列(device queue)：等待特定I/O设备的进程列表。

![img](https://img1.baidu.com/it/u=1371470847,3274411292&fm=26&fmt=auto&gp=0.jpg)

#### 2、调度程序

- 长期调度程序(long-term scheduler)/作业调度程序(job scheduler)：对于批处理系统，提交的进程多于可以立即执行的，这些进程会被保存到大容量存储设备（通常为磁盘）的缓冲池，以便以后执行。该程序从缓冲池中选择进程，加到内存，以便执行。可控制多道程序程度(degree of multiprogramming)（内存中的进程数量），并保证I/O密集型和CPU密集型的合理进程组合。新进程创建频率较低，可承担更多时间。
  - I/O密集型进程(I/O-bound process)：执行I/O比执行计算需要花费更多时间。
  - CPU密集型进程(CPU-bound process)：很少产生I/O请求，更多时间用于执行计算。
- 中期调度程序(medium-term scheduler)：可将进程从内存（或从CPU竞争）中移出（换出），从而降低多道程序程度，之后进程可被重新调入内存（换入），并从中断处继续执行，该方案称为交换。作用：改善进程组合；内存需求改变导致过度使用内存从而需要释放内存。
- 短期调度程序(short-term scheduler)/CPU调度程序(CPU scheduler)：从内存中准备执行的进程中选择进程，并分配CPU。进程执行时间较短，频率较高，因此短期调度程序必须快速。

#### 3、上下文切换

context switch，切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态的过程。当进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。

### 三、进程运行

#### 1、进程创建

进程可创建新的进程，创建进程称为父进程，新进程称为子进程。父进程可能要在子进程之间分配资源或共享资源(如内存或文件)，传递初始化数据。限制子进程只能使用父进程的资源，可以防止创建过多进程，导致系统超载。

执行可能：

- 父进程与子进程并发执行。
- 父进程等待，知道某个或全部子进程执行完。

进程创建后拥有唯一进程标识符pid，可以用作索引访问内核中的进程的各种属性。

#### 2、进程终止

进程执行完后通过系统调用exit()请求操作系统删除自身时进程终止，这时会返回状态值到父进程（通过系统调用wait()）。

- 僵尸进程：子进程已经终止，但父进程未调用wait()
- 孤儿进程：父进程未调用wait()即终止，子进程称为孤儿进程。linux根进程init通过定期调用wait()释放孤儿进程。